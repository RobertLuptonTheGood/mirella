matrices
Mirella supports code for manipulating floating-point matrix arithmetic,
including addition, multiplication by a scalar, inversion, and linear
equation solving.  In Mirella, the matrix name is an executable WORD
which expects arguments--recall that i j matrixname pushes the address
of the i j element. 

The dictionary entry for a matrix contains the row and column dimensions
in the parameter field, as well as the row pointer array address;
Mirella uses that information so you do not need to tell the matrix
arithmetic words how big the matrices are.  Thus matrices are passed by
the CFA of the matrix; the code finds the array address and sizes.  This
is generated by ' matrixname ( ['] matrixname in colon definitions.)
Thus in the descriptions below, 'a, 'b, 'c, etc are such cfa's for
matrices a, b, c... 

The C functions are a bit more complicated, since one must pass dimension
information explicitly, but they are used in the same way. See mirmatrx.c.

The Mirella interface is

    'a 'b 'c  madd          Adds matrices a,b, result in c. n rows, m cols

    'a fc 'b  mcmul         Multiplies the matrix a by the float scalar fc,
                                result in b.
    'a 'b 'c  mmul          Multiplies the matrix a (nxm) by b (mxl) and 
                                stores result in c (nxl)
    'a vec1 vec2  mvmul     Multiplies the matrix a (nxm) by the vector vec1
                                (dim m) and stores the result in the vector 
                                vec2 (dim n). Here and below vectors are passed
                                as addresses to the first element; if the vector
                                is a forth array, 0 vec1, etc.
    vec1 'a vec2  vmmul     Multiplies the vector vec1 (dim n) by the matrix
                                a (nxm) and stores the result in the vector
                                vec2 (dim m).
    'a 'b  matinv           Inverts the square (nxn) matrix a and puts the
                                inverse in b.
    'a bvec xvec  linsolv   Solves the linear system a*xvec = bvec, dim n.

    n m 'a !mdim            Resets the dimension of the matrix a to nxm from
                                whatever it was as allocated. It is up to you
                                to be sure that both n and m never exceed the
                                allocated dimensions; the code has no way of
                                knowing.
    'a @mdim                pushes the row and column dimensions of a
    'a .mdim                prints the "  "     "        "        " "
\math-library

splines
    The spline code is in mirsplin.c. The functions (again the Mirella
    interface; the C interface is almost exactly the same) are: (all
    arrays are floats, and all arrays are passed by the ADDRESS OF THE
    FIRST ELEMENT, 0 x for a Mirella array x )

    fz x y n  linterp       Linearly interpolates in the float ordinate
                                array y defined at the elements of the float
                                abscissa array x, n elements, for the float
                                argument fz.
    x y k n fd21 fd22  gsplinit  Initializes a spline for the abscissa array
                                x, ordinate array y. The derivative array is
                                placed in the array k. n elements. The float
                                second derivatives at the endpoints are fd21
                                and fd22. These are generally not known and are
                                set to zero. This is assumed in the version
    x y k n  splinit        which is otherwise identical.
    fz x y k n  spline      interpolates in the x,y arrays at the (float) 
                                argument z. The derivative dy/dx at z is
                                placed in the global float variable splder, 
                                the interpolated value fpushed.
                                The k array must have been generated by a 
                                call to gsplinit or splinit.
    fa fb x y k n integral  fpushes the definite integral from (float)fa to
                                fb. Again the k array must have been generated
                                first, and of course fa and fb must be 
                                contained in the range of the x array.
    fname xcol ycol spflg filefnarray
                                creates a spline or linear-interpolation func.
                                from a table in the file fname. The abscissa 
                                is in column (0 is first!!) xcol, ordinate
                                in col ycol. spflg=1 if want splines, 0 if
                                linear; computes k if 1. Allocates space for
                                arrays IN DICTIONARY; pushes address of
                                descriptor, which is used as an arg for
    fz desc dotabfun      , which executes the spline or lin interp at arg
                                fz and fpushes result. Or in Mirella you can
                                say
    desc maketabfun funname  which creates a dictionary entry funname so that
    fz funname            executes the function.

The data files for these functions must have blank-delimited columns; they
are terminated by a blank line or EOF; any line beginning with \ is ignored.
                
\math-library
integration + splines
lin_interp + splines

ortho_polys
The orthogonal polynomial generator and fitter is in the file mirorpol.c.
It is a general purpose code designed to fit functions of the form

    P(x)f(x)

where f(x) is an arbitrary function and P(x) is a fitted polynormal, on
an arbitrary net x[i], i=0,...,n-1, with least-squares weights w[i] and
values y[i].  The user must first generate a set of 'superweights' 
W[i] = w[i]*f[i]^2 and a set of 'normalized' abscissae Y[i] = y[i]/f(x[i]);
the code uses only these quantities.

First call

W x n m mkorpol         To generate the polynomials through order m (<=n).
                        The polynomials are stored in static arrays with
                        maximum dimensions 100 points by 10th order at the
                        moment, but can easily be changed. Arrays are passed
                        as addresses to their 0th element, as always.

Then to do the fitting, call

Y ca m orpfit           Which places the polynomial coefficients in the 
                        float array ca, through order m, which must not
                        exceed the maximum order generated. Note that at
                        each m the polynomial generated is the best fitting
                        one of that order.

z ca m poly             fpushes the value of the polynomial defined by the
                        coefficient array ca at x=(float)z.
\math-library

minimization
Mirella supports in C a simple, slow, but very robust function minimizer
which uses the downhill simplex method of Nelder and Mead.  The user
supplies a pointer to a function funk of ndim float variables, which
takes as an argument a pointer to a float array of that dimension which
contains the argument set.  The two implementations differ with respect
to what else is required; the simple one, samoeba(), is in my experience
always satisfactory. 

mirella double 
amoeba(p,ndim,ftol,funk,piter)
/* p is a matrix[ndim+1][ndim] which is initialized to the n+1 vectors of
 *  the starting simplex; at the end, any row is a solution.
 *  ndim is the dimension of the space (number of parameters)
 *  ftol is the fractional tolerance (try 2.e-6 for singles)
 *  funk is the pointer to the function which you are trying to minimize; it
 *  takes a float vector argument of length ndim.
 *  piter is a pointer to the iteration number.
 *  the function returns funk averaged over the final simplex.
 */
float **p;
float ftol;
float (*funk)();
int ndim;
int *piter;

and a simpler version, in which the user guesses an initial location
in the vector x, and an initial set of increments to choose in the
vector dx, again the return value is the function averaged over the
final simplex, and x contains the center of the final simplex.

mirella double 
samoeba(x,dx,funk,nd)   
float *x, *dx;          /* initial guess, initial deltas */
double (*funk)();       /* function */   
int nd;                 /* dimension */
\math-library

histograms
Code in the file mirhist.c supports primitive operations on histograms. 
The basic ingredients are a floating array, farr, of npt values to histogram,
a char array (yesno) acceptance mask, mask, (for which a 1 indicates that the
corresponding element of the value array is to be accepted, a 0,
rejected), a float array, xa,  of abscissae for the CENTERS of the histogram
cells (the indices are thought of as belonging to the centers as well;
cell 0 is the number in -0.5-> +0.5.) and an int histogram array, hist.  No
memory is allocated by these routines. 

The words in the Mirella interface (the C code is similar) are

mask npt initmask           Sets all the elements of mask to 1. Note that
                            arrays are passed as the address of their
                            0th element, as usual, so if you have a 
                            carray hask, you would pass it as 0 hmask.
specarray mask llim ulim npt setmask
                            Sets the values of mask to 0 for those indices
                            for which specarray is outside the (float) limits
                            (llim,ulim). specarray is a float array of the same
                            size as farr and mask.
q hist cellsize origin ncell  puthist
                            Drops the float quantity q into the histogram
                            hist which has cells of float size cellsize and
                            whose 0th cell is centered at origin; ncell cells
                            in all.
hist ncell  clrhist         Sets all the elements of hist to zero.

hist ncell qarr  anhist     Analyzes the histogram hist, places the quartiles
                            (in cells) in the float array (dim 3) qarr. 
                            fpushes the equivalent std dev sigma in cells.
sigma derarray nder  makeder  
                            Makes a float array in derarray which is half 
                            the derivative of a gaussian, from 0 to 3*sigma,
                            (float) sigma expressed in histogram cells. Nder
                            is the dimension of derarray, which must be at
                            least (ceil)3*sigma.
j0 hist ncell derarray nder foldder
                            Convolves hist with derarray, center at cell j0.
                            fpushes result.
hist ncell derarray nder  findmode  
                            Fpushes mode of histogram, found by 
                            looking for zero-crossing of convolution with
                            the derivative of the equivalent gaussian. You
                            must have done an anhist and a makeder previously.
hist ncell stathist         
                            Does a full analysis on the histogram hist; finds
                            mean,std dev,quartiles,and mode; results in 
                            struct hstat_t hist_stat, which is an array
                            of 6 floats: mean,sigma,mode,qt[0],[1],[2].
xar yar mask n sptr gregress
                            Calculates the regression of yar on xar selected
                            by mask, total n elements. results are placed in
                            structure pointed to by sptr, which is an array
                            of three floats; slope,intercept, and corr. coef.
xar yar mask n regress
                            Like gregress, but results in static struct
                            regstat, which is known to Mirella.
\math-library


